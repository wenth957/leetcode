import copy

# python动态语言
'''
1、一切都是对象，占据内存
2、变量名本身无实际意义，只是为了方便使用，放在命名空间
3、引用连接变量和内存：变量指向对象，赋值可以改变引用
一个变量只能指向一个对象，但是一个对象可以由多个变量引用
每个对象会有一个引用计数器，当计数为0时，对象会被回收，内存释放
'''

# 可变对象、不可变对象
'''
不可变对象：创建后不可以被改变，如果非要改变，只能开辟新的内存，创建新的对象：
int、float、long、str、unicode、
tuple、function   相同值指向的是同一块内存（交互终端中：小整数才这样）
可变对象：创建后可以被改变，不需要开辟新内存： 相同值指向不同内存，赋值符号会改变，如果相同，那随意改变，所有都相同了
list dict set 改变方法：append pop remove
'''
a = 'hello'  # 将数据hello的引用保存到变量中
print(id(a))
a += ' world'  # 将数据hello world的引用地址传递到变量中，看起来像值传递
print(id(a))
b = [1, 2, 3]  # 将数据1 2 3的引用保存到变量中
print(id(b))
b.append(3)  # 将3的引用传递到变量中
print(b, id(b))
# 参数传递
'''
引用传递不是值传递：因为变量代表引用
看上去是值传递：因为通常传递的都是不可变对象，引用可代表值
'''
c = 'we'
d = c  # 指向同一块引用
d += 'are'  # 不可变对象，生成新的对象
print(c)  # 看起来像是值传递

# 但是对于可变对象
e = ['the world']
f = e  # 引用传递给了f，指向同一块引用，修改只改变元素的引用，不改变列表的引用
f.append('!')  # 列表引用不变
print(e)  # 引用传递后：f和e指向同一个对象  对可变对象的修改体现在所有引用的变量上  即e上也会体现
# 浅拷贝和深拷贝
'''
copy():复制传入变量指向的对象：如果是可变对象，就会复制所有指向这个对象的引用，只会改变外层id
deepcopy():不但复制引用，而且会将里面的所有对象内存复制一遍，会改变所有内层id
'''
x = [1, 2, [3, 4, [5, 6]]]
print(id(x))
print(id(x[2]), id(x[2][2]))
y = copy.copy(x)
print(id(y))  # 变化了
print(id(x[2]), id(x[2][2]))  # 未变化
z = copy.deepcopy(x)
print(id(z))  # 变化了
print(id(z[2]), id(z[2][2]))  # 变化了
# 函数中的global
# 列表变化，不改变列表的引用 ,只进行append、extend += 操作 不需要global
# 字符串变换，改变字符串引用，需要global
